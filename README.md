# c_network_library_demo

[TOC]

## libev

libev是一个高性能事件驱动库，可以用于开发基于事件驱动的网络应用程序。它提供了一个事件循环和事件处理器，使得开发者可以通过注册回调函数来响应各种事件。

以下是libev的一些主要功能：

- 支持多种事件类型：libev支持多种事件类型，包括文件描述符、信号、定时器等，开发者可以通过注册回调函数来处理这些事件。

- 高性能：libev使用了多种优化技术，如epoll、kqueue等系统调用，以及缓存机制、事件合并等技术，提高了事件处理的效率。

- 可扩展性：libev可以很容易地与其他库和框架集成，如libevent、nginx等。

- 跨平台支持：libev支持多种操作系统，包括Linux、BSD、Solaris等。

- 线程安全：libev可以在多线程环境中使用，多个线程可以共享一个事件循环。

总之，libev是一个非常实用的事件驱动库，可以帮助开发者构建高性能的网络应用程序。

### methods

#### ev_io_init()

ev_io_init(struct ev_io *w, void (*cb)(struct ev_loop *loop, struct ev_io *w, int revents), int fd, int events)

初始化ev_io观察者，用于I/O事件的监听。该函数将ev_io结构体指针w与指定的文件描述符fd和事件类型events进行绑定，并设置回调函数cb用于处理I/O事件。

#### ev_io_start()

ev_io_start(struct ev_loop *loop, struct ev_io *w)

启动ev_io观察者，将其注册到事件循环loop中，开始监听I/O事件。

#### ev_io_stop()

ev_io_stop(struct ev_loop *loop, struct ev_io *w)

停止ev_io观察者，从事件循环loop中移除该观察者，停止监听I/O事件。

#### ev_io_set()

ev_io_set(struct ev_io *w, int fd, int events) 

设置ev_io观察者的文件描述符和事件类型，用于在运行时更改监听的I/O事件。


### structs

### examples

#### io_test01.c

示例程序中，首先初始化了一个libev上下文，并创建了一个ev_io事件观察器来监听标准输入的读取事件。

当标准输入上有数据可读时，stdin_cb回调函数将被调用。在回调函数中，使用read函数读取输入数据并输出到控制台。如果读取出错或读到了文件结束标志，程序将停止监听标准输入并退出事件循环。

在主函数中，启动事件观察器并进入事件循环。当标准输入被关闭或事件循环结束时，程序将释放事件观察器和libev上下文。

#### io_test02.c

示例代码使用了一个ev_io数组io_w和一个int数组fds，分别用于存储多个ev_io观察者和多个文件描述符。

在主函数中，先通过open函数打开两个文件，分别作为文件描述符0和1存入fds数组中。

然后，使用for循环对每个文件描述符都初始化一个ev_io观察者，并将它们都启动起来，开始监听EV_READ事件（即文件可读事件）。

最后，调用ev_run函数进入事件循环，等待I/O事件的到来。

需要注意的是，该示例代码中的ev_io观察者和文件描述符都是在主函数中定义的局部变量，因此在事件循环运行期间不能随意修改它们。如果需要在运行期间动态添加或删除观察者，需要使用动态内存分配等技术，确保能够在事件循环中动态管理I/O事件观察者。

#### io_test03.c

该示例代码中使用ev_set_priority()函数将io_w1的优先级设置为1，将io_w2的优先级设置为2，然后将它们添加到事件循环中。

由于io_w2的优先级高于io_w1，因此在同时有I/O事件到达的情况下，io_w2会被先处理。

#### io_test04.c

在这个示例中，首先打开或创建一个名为“file1.txt”的文件，并使用fchmod()将其设置为不可读取。

然后，创建一个ev_io对象，用于监听文件描述符的读取事件，并设置一个回调函数，当文件描述符可读时触发。

接着，将IO事件添加到事件循环中，并使用fchmod()将文件设置为可读取。

最后，运行事件循环，等待文件描述符可读事件的发生。

#### io_test05.c

在这个示例中，首先打开或创建一个名为“file1.txt”的文件，并使用fchmod()将其设置为不可写入。

然后，创建一个ev_io对象，用于监听文件描述符的写入事件，并设置一个回调函数，当文件描述符可写入时触发。

接着，将IO事件添加到事件循环中，并使用fchmod()将文件设置为可写入。

最后，运行事件循环，等待文件描述符可写入事件的发生。

#### sig_test01.c

用 SIGINT 信号触发 libev 回调的样例代码

## openssl

OpenSSL是一个开源的安全套接字层协议库，提供了很多加密算法和安全协议的实现，例如SSL、TLS、DTLS等。它可以用于构建安全的网络通信应用，比如HTTPS、FTPS等。OpenSSL支持多种操作系统和编程语言，包括C、C++、Java、Python等。

与libev配合使用，通常可以通过以下几个步骤来实现：

- 使用libev创建一个TCP客户端或服务器，连接到目标主机或监听指定端口；

- 在连接或监听成功后，使用OpenSSL创建一个SSL上下文对象（SSL_CTX），并进行SSL会话的初始化；

- 将创建的SSL上下文对象关联到TCP套接字上，以启用SSL安全通信；

- 在进行网络数据传输时，使用OpenSSL提供的加密和解密函数对数据进行加密和解密操作，以保证通信的安全性；

- 在通信结束后，使用OpenSSL释放相关资源。

需要注意的是，使用OpenSSL进行安全通信的过程中，还需要进行证书的验证和管理，以确保通信的安全性。证书的验证和管理涉及到多种复杂的加密算法和协议，需要具备一定的专业知识和技能。

---

要使用 OpenSSL 库连接网站，可以按照以下步骤进行操作：

1. 创建 SSL/TLS 会话上下文：首先需要创建一个 SSL/TLS 会话上下文对象，通过设置 SSL 协议版本、加密算法、证书等信息来配置该对象。可以使用 SSL_CTX_new() 函数创建一个新的 SSL/TLS 会话上下文对象，然后使用 SSL_CTX_set_*() 函数设置 SSL/TLS 会话上下文的相关参数。

2. 创建 TCP 套接字并连接：在连接网站之前，需要先创建一个 TCP 套接字并连接到网站的服务器。可以使用 socket() 函数创建一个新的 TCP 套接字，然后使用 connect() 函数将套接字连接到网站的服务器。

3. 将 SSL/TLS 会话与 TCP 套接字关联：创建 SSL/TLS 会话上下文和 TCP 套接字之后，需要将它们关联起来，以便在 SSL/TLS 握手过程中使用。可以使用 SSL_new() 函数创建一个新的 SSL/TLS 会话对象，然后使用 SSL_set_fd() 函数将该对象与 TCP 套接字关联。

4. 开始 SSL/TLS 握手：在将 SSL/TLS 会话对象与 TCP 套接字关联后，可以使用 SSL_connect() 函数开始 SSL/TLS 握手协议，建立安全通道。

5. 发送和接收数据：完成 SSL/TLS 握手之后，就可以通过 SSL/TLS 会话对象发送和接收数据了。可以使用 SSL_write() 函数发送数据，使用 SSL_read() 函数接收数据。



### structs

#### SSL_CTX

在 OpenSSL 中，`SSL_CTX 对象是 SSL 上下文对象，它是一个包含 SSL 会话配置信息的数据结构。该对象被用于创建和管理 SSL 会话，包括 SSL 握手协议的相关参数，加密和解密算法，以及证书和密钥等信息。可以看作是一个全局的配置，一般在程序初始化时创建，可以被多个SSL连接对象共享。使用SSL_CTX可以提高SSL/TLS连接的效率和安全性。

使用 SSL_CTX 对象可以完成如下功能：

- 加载 SSL 证书和私钥

- 配置 SSL 协议版本和加密算法

- 设置 CA 证书验证等级

- 配置 SSL 会话缓存
SSL是一个具体的SSL/TLS连接对象，代表了一个客户端与服务端之间的安全通道。SSL_CTX对象是创建SSL对象的模板，一个SSL对象必须要与一个SSL_CTX对象关联，才能进行握手和数据传输等操作。在握手过程中，SSL对象会从SSL_CTX对象中获取相关配置信息，例如加密算法、证书、私钥等等，然后通过握手协议和服务端建立安全通道。
- 管理 SSL 会话上下文等

在使用 OpenSSL 进行 SSL 通信时，通常需要先创建一个 SSL_CTX 对象，然后使用该对象创建一个 SSL 会话上下文，最后通过该上下文对象创建 SSL 连接。

#### SSL

SSL是一个具体的SSL/TLS连接对象，代表了一个客户端与服务端之间的安全通道。SSL_CTX对象是创建SSL对象的模板，一个SSL对象必须要与一个SSL_CTX对象关联，才能进行握手和数据传输等操作。在握手过程中，SSL对象会从SSL_CTX对象中获取相关配置信息，例如加密算法、证书、私钥等等，然后通过握手协议和服务端建立安全通道。

## wslay

wslay是一个轻量级的WebSocket协议库，支持WebSocket协议的所有规范，包括WebSocket握手、帧格式、消息分片等。wslay的设计目标是高性能、易用性和可移植性，它提供了简单的API接口和灵活的事件处理机制，可以用于实现WebSocket客户端和服务器应用。

wslay可以与libev配合使用，以实现异步、非阻塞的WebSocket通信。一般来说，可以通过以下几个步骤来实现：

- 使用libev创建一个TCP客户端或服务器，连接到目标主机或监听指定端口；

- 在连接或监听成功后，使用wslay创建一个WebSocket会话对象（wslay_event_context），并进行WebSocket握手；

- 将创建的WebSocket会话对象关联到TCP套接字上，以启用WebSocket通信；

- 在进行网络数据传输时，使用wslay提供的事件处理函数对WebSocket消息进行处理，包括消息帧的解析、消息的分片、消息的组装等；

- 在WebSocket通信结束后，使用wslay释放相关资源。

需要注意的是，使用wslay进行WebSocket通信 的过程中，还需要遵循WebSocket协议的规范和标准，包括消息格式、状态码、错误处理等。在处理WebSocket消息时，需要特别注意消息分片、消息合并、控制帧的处理等问题，以确保通信的正确性和稳定性。

综上所述，使用wslay与libev配合使用可以实现高性能、异步、非阻塞的WebSocket通信，但需要遵循WebSocket协议的规范和标准，注意消息的分片和合并、控制帧的处理等问题。

## nghttp2

HTTP/2协议是一种二进制协议，相对于HTTP/1.x协议具有更高的性能和更好的压缩性能。nghttp2是一个开源的HTTP/2实现库，支持多种语言和操作系统。

下面介绍如何使用libev和nghttp2实现异步、非阻塞的HTTP/2协议通信：

- 使用libev创建一个TCP客户端或服务器，连接到目标主机或监听指定端口；

- 在连接或监听成功后，使用nghttp2创建一个会话对象（nghttp2_session），并进行HTTP/2握手；

- 将创建的会话对象关联到TCP套接字上，以启用HTTP/2协议通信；

- 在进行网络数据传输时，使用nghttp2提供的事件处理函数对HTTP/2消息进行处理，包括消息帧的解析、消息的分片、消息的组装等；

- 在HTTP/2通信结束后，使用nghttp2释放相关资源。

需要注意的是，使用nghttp2进行HTTP /2通信的过程中，还需要遵循HTTP/2协议的规范和标准，包括消息格式、状态码、错误处理等。在处理HTTP/2消息时，需要特别注意消息分片、消息合并、帧优先级、流控制等问题，以确保通信的正确性和稳定性。

## llhttp

## Kernel bypass

Kernel bypass（内核旁路）是一种网络协议栈的设计方法，旨在绕过操作系统内核的网络协议处理，直接将数据传输到网卡上进行处理。这种方法可以极大地提高网络性能和吞吐量，特别是在高负载、高并发的网络环境中。

传统的网络协议栈通常是由操作系统内核负责管理和处理的，每个数据包都需要经过多个内核层进行处理和转发。这种方式的好处是方便管理和维护，但是在高负载和高并发的情况下，会对系统性能造成很大的影响。

通过Kernel bypass技术，网络数据包可以直接从网卡上读取和写入，避免了内核层的处理，提高了系统的性能和吞吐量。这种方法通常需要使用专门的硬件设备或驱动程序来实现，并且需要针对不同的硬件平台和网络协议进行优化和调整。常见的Kernel bypass实现方式包括DPDK、Netmap、XDP等。